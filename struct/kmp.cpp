#include <iostream>
using namespace std;
const int N = 10e5 + 10, M = 10e6 + 10;

char p[N], s[M];
int ne[N];

int main()
{
    int n,m;
    // 这个录入方法可以学习
    cin >> n >> p + 1 >> m >> s + 1;
    // 求ne过程
    // ne[1] = 0 所以从2开始
    // 循环结束条件是 小于等于 n 
    for (int i = 2, j = 0; i <= n; i++)
    {
        // 双指针
        while (j && p[j + 1] != p[i]) j = ne[j];
        if (p[j + 1] == p[i]) j ++;
        // 给它存入数组
        ne[i] = j;
    }
    
    // 匹配过程
    // 匹配中 j+1 代表着子串将要匹配的点 i表示将要匹配的点
    // i从1开始 j从0开始 这样设计方便ne的实现
    for (int i = 1, j = 0; i <= m; i++)
    {
        while (j && p[j + 1] != s[i]) j = ne[j];
        if (p[j + 1] == s[i]) j ++;
        // 匹配完最后一位了，所以这时j应该时超出数组范围的，应该等于n而非n-1
        if (j == n)
        {
            // 晕，这里又不+1了 因为我们是从1开始录入的 但是答案从0开始计数
            // 假设 s = "abc" p = "a" 那么匹配成功时i = 1 1-1=0结果是对的
            cout << i - n<< ' '; 
            // 只小小回退一下
            j = ne[j]; 
        }
    }
}

// 从0开始录入版本
// int main()
// {
//     cin >> n >> p >> m >> s;

//     // p[0...0] 的区间内一定没有相等前后缀
//     ne[0] = -1;

//     // 构造模板串的 next 数组
//     for (int i = 1, j = -1; i < n; i ++)
//     {
//         while (j != -1 && p[i] != p[j + 1])
//         {
//             // 若前后缀匹配不成功
//             // 反复令 j 回退，直至到 -1 或是 s[i] == s[j + 1]
//             j = ne[j];
//         }
//         if (p[i] == p[j + 1]) 
//         {
//             j ++; // 匹配成功时，最长相等前后缀变长，最长相等前后缀最后一位变大
//         }
//         ne[i] = j; // 令 ne[i] = j，以方便计算 next[i + 1]
//     }

//     // kmp start !
//     for (int i = 0, j = -1; i < m; i ++)
//     {
//        while (j != -1 && s[i] != p[j + 1])
//        {
//            j = ne[j];
//        }
//        if (s[i] == p[j + 1])
//        {
//            j ++; // 匹配成功时，模板串指向下一位
//        }
//        if (j == n - 1) // 模板串匹配完成，第一个匹配字符下标为 0，故到 n - 1
//        {
//            // 匹配成功时，文本串结束位置减去模式串长度即为起始位置
//            cout << i - j << ' ';

//            // 模板串在模式串中出现的位置可能是重叠的
//            // 需要让 j 回退到一定位置，再让 i 加 1 继续进行比较
//            // 回退到 ne[j] 可以保证 j 最大，即已经成功匹配的部分最长
//            j = ne[j]; 
//        }
//     }

//    return 0;
// }

